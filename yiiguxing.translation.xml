<application>
  <component name="AppStorage">
    <option name="newTranslationDialogX" value="540" />
    <option name="newTranslationDialogY" value="-775" />
    <histories>
      <item value="Batch Update Effective Objectbox Action" />
      <item value="does not operate by default on a particular" />
      <item value="inverted" />
      <item value="Granularity" />
      <item value="Hierarchy" />
      <item value="Generic" />
      <item value="gauge" />
      <item value="Add an {@link ItemDecoration} to this RecyclerView. Item decorations can affect both measurement and drawing of individual item views. &lt;p&gt;Item decorations are ordered. Decorations placed earlier in the list will be runquerieddrawn first for their effects on item views. Padding added to views will be nested; a padding added by an earlier decoration will mean further item decorations in the list will be asked to drawpad within the previous decoration's given area.&lt;p&gt;" />
      <item value="@param dx x distance in pixels. @param dy y distance in pixels. @param interpolator {@link Interpolator} to be used for scrolling. If it is {@code null}, RecyclerView will use an internal default interpolator. @param duration Duration of the animation in milliseconds. Set to {@link UNDEFINED_DURATION} to have the duration be automatically calculated based on an internally defined standard initial velocity. A duration less than 1 (that does not equal UNDEFINED_DURATION), will result in a call to {@link scrollBy(int, int)}. @param withNestedScrolling True to perform the smooth scroll with nested scrolling. If {@code duration} is less than 0 and not equal to {@link UNDEFINED_DURATION}, smooth scrolling will not occur and thus no nested scrolling will occur. Should be considered private. Not private to avoid synthetic accessor." />
      <item value="Internal smooth scroll by implementation that currently has some tricky logic related to it's parameters. &lt;ul&gt; &lt;li&gt;For scrolling to occur, on either dimension, dx or dy must not be equal to 0 and the {@link LayoutManager} must support scrolling in a direction for which the value is not 0. &lt;li&gt;For smooth scrolling to occur, scrolling must occur and the duration must be equal to {@link UNDEFINED_DURATION} or greater than 0. &lt;li&gt;For scrolling to occur with nested scrolling, smooth scrolling must occur and {@code withNestedScrolling} must be {@code true}. This could be updated, but it would require that {@link scrollBy(int, int)} be implemented such that it too can handle nested scrolling." />
      <item value="nanoseconds" />
      <item value="When using a capacity-restricted queue, this method is generally preferable to method {@link BlockingQueueadd add}, which can fail to insert an element only by throwing an exception." />
      <item value="preferable" />
      <item value="lock Interruptibly" />
      <item value="Inserts the specified element at the tail of this queue, waiting if necessary for space to become available." />
      <item value="queue" />
      <item value="Deque" />
      <item value="Array Deque" />
      <item value="portrait" />
      <item value="protrai" />
      <item value="portal" />
      <item value="Default cache usage mode. If the navigation type doesn't impose any specific behavior, use cached resources when they are available and not expired, otherwise load resources from the network. Use with {@link setCacheMode}." />
      <item value="Foreground" />
      <item value="A global coroutine to log statistics every second, must be always active" />
      <item value="reduce" />
      <item value="Enforces that the value of a property is unique among all objects in a box before an object can be put. &lt;p&gt; Trying to put an object with offending values will result in a UniqueViolationException. &lt;p&gt; Unique properties are based on an {@link Index @Index}, so the same restrictions apply. It is supported to explicitly add the {@link Index @Index} annotation to configure the index." />
      <item value="A filter requires to instantiate full Java objects beforehand, which is less efficient." />
      <item value="Sets a filter that executes on primary query results (returned from the db core) on a Java level. For efficiency reasons, you should always prefer primary criteria like {@link equal(Property, String)} if possible. A filter requires to instantiate full Java objects beforehand, which is less efficient. &lt;p&gt; The upside of filters is that they allow any complex operation including traversing object graphs, and that filtering is executed along with the query (preferably in a background thread). Use filtering wisely ;-). &lt;p&gt; Also note, that a filter may only be used along with {@link Queryfind()} and {@link QueryforEach(QueryConsumer)} at this point. Other find methods will throw a exception and aggregate functions will silently ignore the filter." />
      <item value="Sets a filter that executes on primary query results (returned from the db core) on a Java level. For efficiency reasons, you should always prefer primary criteria like {@link equal(Property, String)} if possible" />
      <item value="beforehand" />
      <item value="improperly" />
      <item value="Serialized" />
      <item value="&lt;p&gt;Calling this method several times before the next frame (for example, if unrelated code also wants to make dynamic changes and run a transition on the same scene root), only the first call will trigger capturing values and exiting the current scene. Subsequent calls to the method with the same scene root during the same frame will be ignored.&lt;p&gt;" />
      <item value="Convenience method to animate to a new scene defined by all changes within the given scene root between calling this method and the next rendering frame. Calling this method causes TransitionManager to capture current values in the scene root and then post a request to run a transition on the next frame. At that time, the new values in the scene root will be captured and changes will be animated. There is no need to create a Scene; it is implied by changes which take place between calling this method and the next frame when the transition begins." />
      <item value="implied" />
      <item value="Lyric" />
      <item value="Transition" />
      <item value="Sets a filter that executes on primary query results (returned from the db core) on a Java level. For efficiency reasons, you should always prefer primary criteria like {@link equal(Property, String)} if possible. A filter requires to instantiate full Java objects beforehand, which is less efficient." />
      <item value="Visit Objectbox Action" />
      <item value="The binary version of its metadata is 1.6.0, expected version is 1.4.1" />
      <item value="incompatible" />
      <item value="Annotation for an entity base class. ObjectBox will include properties of an entity super class marked with this annotation." />
      <item value="flashingboy" />
      <item value="universal" />
      <item value="Inspector" />
      <item value="Accepts the given [collector] and [emits][FlowCollector.emit] values into it. This method should never be implemented or used directly. The only way to implement the `Flow` interface directly is to extend [AbstractFlow]. To collect it into a specific collector, either `collector.emitAll(flow)` or `collect { ... }` extension should be used. Such limitation ensures that the context preservation property is not violated and prevents most of the developer mistakes related to concurrency, inconsistent flow dispatchers and cancellation." />
      <item value="spine" />
      <item value="spine View" />
      <item value="Set's the [LiveData]'s value to the given [value]. If you've called [emitSource] previously, calling [emit] will remove that source. Note that this function suspends until the value is set on the [LiveData]. @param value The new value for the [LiveData] @see emitSource" />
      <item value="Applies (persists) tracked changes (added and removed entities) to the target box andor updates standalone relations. Note that this is done automatically when you put the source entity of this to-many relation. However, if only this to-many relation has changed, it is more efficient to call this method. @throws IllegalStateException If the source entity of this to-many relation was not previously persisted" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="106" />
        <entry key="ENGLISH" value="107" />
        <entry key="SOMALI" value="1" />
        <entry key="ITALIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1653970100896" />
  </component>
  <component name="Settings">
    <option name="phoneticFontFamily" value=".SFNS-Regular" />
    <option name="primaryFontFamily" value=".SFNS-Regular" />
  </component>
</application>